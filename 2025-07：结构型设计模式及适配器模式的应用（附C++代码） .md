# 结构型设计模式及适配器模式的应用（附C++代码）

**原文链接**：[https://refactoringguru.cn/design-patterns](https://refactoringguru.cn/design-patterns)


结构性设计模式用于类之间的组织。

### 适配器

目的：

- 新类兼容旧接口，提供桥接转换功能。如：xml转json，再用json的工具。

```cpp
#include <string>
#include <iostream>
#include <algorithm>

// 已有类
class Target 
{
 public:
  virtual ~Target() = default;

  virtual std::string Request() const 
  {
    return "Target: The default target's behavior.";
  }
};

// 需要转换才能使用的类
class Adaptee 
{
 public:
  std::string SpecificRequest() const 
  {
    return ".eetpadA eht fo roivaheb laicepS";
  }
};

// 桥接已有类和需转换的类
class Adapter : public Target //要点1：继承已有类
{ 
 private:
  Adaptee *adaptee_; //要点2：包含待转换对象

 public:
  Adapter(Adaptee *adaptee) : adaptee_(adaptee) {}
  std::string Request() const override //重写方法
  { 
    std::string to_reverse = this->adaptee_->SpecificRequest();
    std::reverse(to_reverse.begin(), to_reverse.end());
    return "Adapter: (TRANSLATED) " + to_reverse;
  }
};

// 客户端代码不用变，还是Target接口
void ClientCode(const Target *target) 
{
  std::cout << target->Request();
}

int main() 
{
  Target *target = new Target;
  ClientCode(target);
  std::cout << "\n\n";
	
  Adaptee *adaptee = new Adaptee;
  Adapter *adapter = new Adapter(adaptee);
  ClientCode(adapter);

  delete target;
  delete adaptee;
  delete adapter;

  return 0;
}
```

#### 使用适配器设计模式，替换卡尔曼滤波器

背景：在一个多传感器融合的项目代码中，我一直使用如下接口的卡尔曼滤波器。而随着代码逐渐庞大，该接口已经遍布融合程序的各个地方，不易进行替换和改动。

```cpp
struct MotionState // 滤波状态数据结构
{ 
    Eigen::Vector3f             position;
    Eigen::Vector3f             velocity;
    Eigen::Vector3f             acc;
    // x,y,z,vx,vy,vz,ax,ay,az
    Eigen::Matrix<float, 9, 1>  mean; 
    Eigen::Matrix<float, 9, 9>  covar;
};


class MotionKalmanFilter
{
public:
    Eigen::Matrix<float, 9, 9>  mCovarPredict;
    Eigen::Matrix<float, 3, 3>  mCovarMeasure;
    Eigen::Matrix<float, 9, 9>  A;
    Eigen::Matrix<float, 3, 9>  H;

public:
    MotionKalmanFilter();

    virtual ~MotionKalmanFilter();

    void updateStates(std::shared_ptr<MotionState> ptr);

    std::shared_ptr<MotionState> initiate(Eigen::Vector3f measurement);

    void predict(std::shared_ptr<MotionState> ptr, float mDeltaTime);

    void update(std::shared_ptr<MotionState> ptr, Eigen::Vector3f measurement);

};

```

融合程序中卡尔曼滤波器的使用：

```cpp
// 举例：在目标关联匹配后的更新阶段
void Fuse::MatchUpdate(const std::vector<std::vector<int>>& matches, std::vector<std::shared_ptr<Track>>& tracks, const std::vector<Obj>& measurements)
{
    for (auto match : matches)
    {   
            std::shared_ptr<Track> track = tracks[match[0]];
            Obj measurement = measurements[match[1]];

			// ...省略其他细节...
            std::cout << "[INFO] [Match Update] : track_id-" << track->fuse_object->track_id << " updates with Sensor-" << cur_sensor_id << " track_id-" << measurement.track_id << std::endl;
            
            // 卡尔曼滤波器预测
            motion_kf.predict(track->motion_state, time_diff);
            // 构造滤波器接受的数据类型
            Eigen::Vector3f measurement_position(measure_x, measure_y, 0.0);
            // 卡尔曼滤波器更新
            motion_kf.update(track->motion_state, measurement_position);
            

            track->fuse_object->x = track->motion_state->position(0);
            track->fuse_object->y = track->motion_state->position(1);
            track->fuse_object->vx = track->motion_state->velocity(0);
            track->fuse_object->vy = track->motion_state->velocity(1);
            // ...省略其他细节...
        }
    }
}
```

此时，由于使用的卡尔曼滤波器性能不稳定，我想替换成另一个卡尔曼滤波器测试。但是它有不同的接口：

```cpp

struct ESKFState 
{
    // Nominal state (x, y, vx, vy)
    Eigen::Vector4f             nominal_state;  
    
    // Error state (dx, dy, dvx, dvy)
    Eigen::Vector4f             error_state;   
    
    // Covariance of error state (4x4)
    Eigen::Matrix4f             error_covar;   
    
    // Measurement noise (x, y)
    Eigen::Matrix2f             measure_noise; 
};


class ESKFilter 
{
public:
    ESKFilter(float process_noise_pos = 0.001f, float process_noise_vel = 0.01f);
    
    void predict(std::shared_ptr<ESKFState> state, float delta_time);

    void update(std::shared_ptr<ESKFState> state, const Eigen::Vector2f& measurement);

    std::shared_ptr<ESKFState> initialize(const Eigen::Vector2f& initial_pos);


private:
    Eigen::Matrix4f m_process_noise_scaling;  // 过程噪声的基础比例（与delta_time无关部分）

    Eigen::Matrix<float, 2, 4> m_H;           // 观测矩阵 (固定)
};
```

如果我将每个数据结构都从MotionState变为ESKFState，需要很大的工作量。此时就可以用适配器模式。首先，改造MotionState数据结构：

```cpp
struct MotionState
{ 
    Eigen::Vector3f             position;
    Eigen::Vector3f             velocity;
    Eigen::Vector3f             acc;
    // x,y,z,vx,vy,vz,ax,ay,az
    Eigen::Matrix<float, 9, 1>  mean; 
    Eigen::Matrix<float, 9, 9>  covar;

    ESKFState                   eskf_state; // 将ESKFState作为MotionState的一个属性
};

```

然后，构造一个ESKFMotionKalmanFilter来继承MotionKalmanFilter，在新类的每一个方法首尾，添加转换步骤，实现如下：

```cpp

class ESKFMotionKalmanFilter : public MotionKalmanFilter
{
private:
    std::shared_ptr<ESKFilter> eskf = std::make_shared<ESKFilter>(0.001f, 0.01f);  // 适配器类中将保存一个内置对象

    
public:
    ESKFMotionKalmanFilter() {};


    ~ESKFMotionKalmanFilter() {};


    std::shared_ptr<MotionState> initiate(Eigen::Vector3f measurement)
    {   
        // input convert
        Eigen::Vector2f initial_measurement(measurement(0), measurement(1));

        // opt
        auto state = eskf->initialize(initial_measurement);
       
        // output convert
        std::shared_ptr<MotionState> ptr(new MotionState);
        ptr->mean(0, 0) = state->nominal_state(0);
        ptr->mean(1, 0) = state->nominal_state(1);
        ptr->mean(3, 0) = state->nominal_state(2);
        ptr->mean(4, 0) = state->nominal_state(3);
        updateStates(ptr);
        ptr->eskf_state = *state;

        return ptr;
    }


    void predict(std::shared_ptr<MotionState> ptr, float mDeltaTime)
    {
        // input convert
        std::shared_ptr<ESKFState> state = std::make_shared<ESKFState>(ptr->eskf_state);
        
        // opt 
        eskf->predict(state, mDeltaTime);

        // output convert
        ptr->mean(0, 0) = state->nominal_state(0);
        ptr->mean(1, 0) = state->nominal_state(1);
        ptr->mean(3, 0) = state->nominal_state(2);
        ptr->mean(4, 0) = state->nominal_state(3);
        updateStates(ptr);
        ptr->eskf_state = *state;
    }


    void update(std::shared_ptr<MotionState> ptr, Eigen::Vector3f measurement)
    {
        // input convert
        Eigen::Vector2f update_measurement(measurement(0), measurement(1));
        std::shared_ptr<ESKFState> state = std::make_shared<ESKFState>(ptr->eskf_state);
        // opt
        eskf->update(state, update_measurement);

        // output convert
        ptr->mean(0, 0) = state->nominal_state(0);
        ptr->mean(1, 0) = state->nominal_state(1);
        ptr->mean(3, 0) = state->nominal_state(2);
        ptr->mean(4, 0) = state->nominal_state(3);
        updateStates(ptr);
        ptr->eskf_state = *state;
    }

    void updateStates(std::shared_ptr<MotionState> ptr)
    {
        ptr->position(0) = ptr->mean(0, 0);
        ptr->position(1) = ptr->mean(1, 0);
        ptr->position(2) = ptr->mean(2, 0);

        ptr->velocity(0) = ptr->mean(3, 0);
        ptr->velocity(1) = ptr->mean(4, 0);
        ptr->velocity(2) = ptr->mean(5, 0);

        ptr->acc(0) = ptr->mean(6, 0);
        ptr->acc(1) = ptr->mean(7, 0);
        ptr->acc(2) = ptr->mean(8, 0);
    }
};
```

此时，无需改动融合程序的接口，就能将MotionKalmanFilter改为ESKFilter进行测试。


### 组合

目的：

- 管理树状数据结构，需要某个操作递归累积到所有子对象。
- 复杂类和简单类（叶子节点）继承通用接口。

```cpp
#include <algorithm>
#include <iostream>
#include <list>
#include <string>

// 复杂对象和简单对象的通用接口
class Component 
{
 protected:
  Component *parent_;
	
 public:
  virtual ~Component() {}
	
  void SetParent(Component *parent) 
  {
    this->parent_ = parent;
  }
	
  Component *GetParent() const 
  {
    return this->parent_;
  }
  
  virtual void Add(Component *component) {}
	
  virtual void Remove(Component *component) {}

  //是否可以包含子对象
  virtual bool IsComposite() const 
  {
    return false;
  }

	// 通用操作
  virtual std::string Operation() const = 0;
};

// 简单对象
class Leaf : public Component 
{
 public:
  std::string Operation() const override 
  {
    return "Leaf";
  }
};

class Composite : public Component {
 protected:
  std::list<Component *> children_;

 public:
  
  void Add(Component *component) override 
  {
    this->children_.push_back(component);
    component->SetParent(this);
  }

  void Remove(Component *component) override 
  {
    children_.remove(component);
    component->SetParent(nullptr);
  }
	
  bool IsComposite() const override 
  {
    return true;
  }
  
  std::string Operation() const override 
  {
    std::string result;
    for (const Component *c : children_) {
      if (c == children_.back()) {
        result += c->Operation();
      } else {
        result += c->Operation() + "+";
      }
    }
    return "Branch(" + result + ")";
  }
};

void ClientCode(Component *component) 
{
  std::cout << "RESULT: " << component->Operation();
}

void ClientCode2(Component *component1, Component *component2) 
{
  if (component1->IsComposite()) {
    component1->Add(component2);
  }
  std::cout << "RESULT: " << component1->Operation();
}

int main() 
{
  
  Component *simple = new Leaf;
  std::cout << "Client: I've got a simple component:\n";
  ClientCode(simple);
  std::cout << "\n\n";

  Component *tree = new Composite;
  Component *branch1 = new Composite;

  Component *leaf_1 = new Leaf;
  Component *leaf_2 = new Leaf;
  Component *leaf_3 = new Leaf;
  branch1->Add(leaf_1);
  branch1->Add(leaf_2);
  Component *branch2 = new Composite;
  branch2->Add(leaf_3);
  tree->Add(branch1);
  tree->Add(branch2);
  std::cout << "Client: Now I've got a composite tree:\n";
  ClientCode(tree);
  std::cout << "\n\n";

  std::cout << "Client: I don't need to check the components classes even when managing the tree:\n";
  ClientCode2(tree, simple);
  std::cout << "\n";

  delete simple;
  delete tree;
  delete branch1;
  delete branch2;
  delete leaf_1;
  delete leaf_2;
  delete leaf_3;

  return 0;
}
```

### 装饰

目的：

- 不为基本功能扩展代码的前提下，在该基础功能的前后添加一些操作。如：发送邮箱消息后，再发微信、QQ等消息

```cpp
#include <string>
#include <iostream>

// 基础组件基类
class Component 
{
 public:
  virtual ~Component() {}
  virtual std::string Operation() const = 0;
};

// 具体组件类
class ConcreteComponent : public Component 
{
 public:
  std::string Operation() const override 
  {
    return "ConcreteComponent"; // 基础功能
  }
};

// 装饰基类
class Decorator : public Component // 继承组件类
{
 protected:
  Component* component_; // 包含一个基本

 public:
  Decorator(Component* component) : component_(component)  {} // 用组件类初始化
  
  std::string Operation() const override // 接口名字要和组件类一致
  {
    return this->component_->Operation(); // 组件类方法
  }
};

class ConcreteDecoratorA : public Decorator 
{

 public: 
	// 注意：此处初始化成员的方式：类名限定用法
  ConcreteDecoratorA(Component* component) : Decorator(component) {}
  
  std::string Operation() const override 
  {
  	// 在组件类操作的前后做一些其他操作
    return "ConcreteDecoratorA(" + Decorator::Operation() + ")";
  }
};

class ConcreteDecoratorB : public Decorator 
{
 public:
  ConcreteDecoratorB(Component* component) : Decorator(component) {}

  std::string Operation() const override 
  {
    return "ConcreteDecoratorB(" + Decorator::Operation() + ")";
  }
};

// 客户端代码不关心是组件类 or 装饰类
void ClientCode(Component* component) 
{
  std::cout << "RESULT: " << component->Operation();
}

int main() 
{
  Component* simple = new ConcreteComponent;
  std::cout << "Client: I've got a simple component:\n";
  ClientCode(simple);
  std::cout << "\n\n";
  
  // Decorator可以套娃
  Component* decorator1 = new ConcreteDecoratorA(simple);
  Component* decorator2 = new ConcreteDecoratorB(decorator1);
  std::cout << "Client: Now I've got a decorated component:\n";
  ClientCode(decorator2);
  std::cout << "\n";

  delete simple;
  delete decorator1;
  delete decorator2;

  return 0;
}
```

### 外观

目的：

- 将复杂类/方法，通过一个简单的类包装起来

思想简单，代码不用看

```cpp
class Subsystem1 
{
 public:
  std::string Operation1() const 
  {
    return "Subsystem1: Ready!\n";
  }

  std::string OperationN() const 
  {
    return "Subsystem1: Go!\n";
  }
};

class Subsystem2 
{
 public:
  std::string Operation1() const
  {
    return "Subsystem2: Get ready!\n";
  }

  std::string OperationZ() const 
  {
    return "Subsystem2: Fire!\n";
  }
};

// 外观类
class Facade 
{
 protected:
  Subsystem1 *subsystem1_;
  Subsystem2 *subsystem2_;

 public:

  Facade(
      Subsystem1 *subsystem1 = nullptr,
      Subsystem2 *subsystem2 = nullptr) 
  {
    this->subsystem1_ = subsystem1 ?: new Subsystem1;
    this->subsystem2_ = subsystem2 ?: new Subsystem2;
  }
	
  ~Facade() 
  {
    delete subsystem1_;
    delete subsystem2_;
  }
  
  // 简洁接口：
  std::string Operation() 
  {
    std::string result = "Facade initializes subsystems:\n";
    result += this->subsystem1_->Operation1();
    result += this->subsystem2_->Operation1();
    result += "Facade orders subsystems to perform the action:\n";
    result += this->subsystem1_->OperationN();
    result += this->subsystem2_->OperationZ();
    return result;
  }
};

// 客户端代码与外观类交互
void ClientCode(Facade *facade) 
{
  std::cout << facade->Operation();
}

int main() 
{
  Subsystem1 *subsystem1 = new Subsystem1;
  Subsystem2 *subsystem2 = new Subsystem2;
  Facade *facade = new Facade(subsystem1, subsystem2);
  ClientCode(facade);

  delete facade;

  return 0;

```